# HashMap

## 数据结构

- jdk 1.7 使用的是数组 + 链表
- jdk 1.8 使用的是 数组+ 链表+ 红黑树：
    - 树化：一条链表长度>8 并且 hashmap 的节点总数大于64 就转换为数据结构，使用红黑树
    - 退化：一条链表长度<6

## 扩容

初始是16，负载因子是0.75，threshold = 16*0.75 =12

## put 详细流程：`putVal （hash(key)，key，value）`

定义了一个 e 的节点，去判断是否找到key 相同的节点

1. 是不是为当前表是否已经初始化，如果没有，那么调用 `resize()`<mark>（这是整个方法中第一个resize）</mark> 去初始化
2. 计算 桶的下标，判断这个桶是不是为null
    1. 如果桶为空，直接放这个节点下去
    2. 如果桶不为空
        1. 先判断第一个节点 和 待插入的节点 hash和key 是不是相同
            1. 相同，相当于就找到了这个节点
        2. 判断树的节点是不是 红黑树的节点，如果是，调用红黑树的插入
        3. 以下说明是正常链表的逻辑了
            1. 遍历链表，如果遍历完了还没有找到 key 相同的，尾插。判断 是否是否树化
            2. 如果遍历过程中，找到了。跳出循环。

判断 e 是不是为null

- 如果是null，在过程中也进行了插入操作
- 如果不是null，替换值了，返回旧值

判断元素个数是否超过阈值，如果超过 扩容<mark>（这是整个方法中第二个resize）</mark>

## resize () 过程

- 旧hash 表
- 旧hash 表长度
- 旧阈值
- 定义新长度、阈值

1. 已经初始化了 ：通过判断旧长度 是 大于0
    1. 是否可以扩，
2. 阈值设置了，hash 表没有初始化
3. 都没有设置，设置为默认的 阈值和 容量。

如果桶里面仅有一个节点，路由公式，hash & (newCap-1)

如果是树，拆分树

如果是 链表，那么1. 7 rehash, 1.8 是判断，`hash & oldCap ==0` 低位，否则高位
前提: 我们知道分配后的元素可能出现在两个地方，第一个是旧索引，第二个是旧索引 + `oldCap`
那么可以通过`hash & oldCap ==0`判断。

- `oldCap` 总是 `2ⁿ`，在二进制里是个“1 后面跟 n 个 0”（例如 8 = `1000`）。
- 对某个节点的 `hash` 做位与，就相当于看它在那一位（对应 `oldCap`）是 0 还是 1：
    - 如果是 0 → 新表索引 = 旧索引
    - 如果是 1 → 新表索引 = 旧索引 + `oldCap`

这样就能 **O(1)** 地决定每个元素是留在原来的槽，还是搬到“对称”槽，实现高效重分布。